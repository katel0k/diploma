Была выдвинута гипотеза, заключающаяся в том что Dream EML показывает плохие результаты из-за большого количества аллокаций. % // TODO: попробовать замерить эти параметры для остальных препроцессоров
Дело в том что для сохранения чистоты функций, используемых dream eml, для каждого шаблона создается свой буфер для временных данных.
Проверить эту гипотезу несложно, достаточно запустить инструменты замера количества аллокаций. Результаты представлены в этой таблице:

% // TODO: добавить таблицу результатов запуска valgrind

Как видно, количество аллокаций растет линейно с размером программы. Однако, эти аллокации не являются необходимыми и сразу же выкидываются после завершения исполнения функции.

Сами аллокации памяти занимают много времени % // TODO докинуть литературу/собственные тесты подтверждающую что это занимает много времени


\section{Анализ узкого места}
Исходная реализация:
\begin{lstlisting}
let render buffer = 
  ...
  Buffer.add_string buffer (Buffer.contents local_buffer)
\end{lstlisting}


Решение простое - добавить пул из заранее аллоцированных буферов для рендеринга.

В связи с природой фреймворка, этот пул должен будет создаваться в начале каждого файла, проходящего через препроцессинг.

\textbf{Проблема}: создание временного буфера для каждого компонента → O(n) аллокаций.
% // TODO исправить вставку кода
\section{Механизм пула буферов}
Предложенное решение:
\begin{lstlisting}
let ___EML_BUFFER_SIZE = %d
let ___EML_POOL_SIZE = %d
let ___eml_pool = ref (List.init ___EML_POOL_SIZE 
  (fun _ -> Buffer.create ___EML_BUFFER_SIZE))
let ___eml_get_buffer pool =
  match !pool with
  | buf :: bufs ->
    pool := bufs;
    Buffer.clear buf;
    buf
  | [] -> Buffer.create ___EML_BUFFER_SIZE
let ___eml_return_buffer pool buf =
  pool := buf :: !pool;
  Buffer.contents buf

\end{lstlisting}



Константы для размеров буфера задаются при запуске программы. Поскольку ее запуск производится на каждый файл, для каждого файла возможно указать свой размер.
Эта настрйока релевантна для страниц, имеющих обратную проблему - малое количество рендерингов большого объема. % // TODO: сделать бенчмарк доказывающий это утверждение должно быть несложно

По умолчанию создается всего 1 буфер размеров 4096 символов.

% // TODO замерить количество оперативной памяти потребляемой программой в сравнении с остальными фреймворками

\textbf{Эффект}:
\begin{itemize}
    \item Константное число аллокаций (при инициализации)
    \item Сохранение чистоты функций
    \item Ускорение рендеринга в 
\end{itemize}

Важное уточннение по поводу многопоточносити. Dream использует lwt для организации многопоточности, однако в пуле полученном выше не упоминается многопоточность. Это связано с тем что lwt имеет конкуррентную модель многопоточности. Только один поток за раз имеет доступ к памяти. Как следствие, mutex на пул навешивать не надо.

% // TODO попробовать сделать тест и на это?



