Фреймворки сравниваются по следующим качественным параметрам, каждый из которых описан в деталях далее:
\begin{itemize}
    \item Популярность
    \item Вычисление покрытия
    \item Экосистема
    \item Дебаггинг
    \item Тестируемость
\end{itemize}

А также по следующим количественным параметрам, также описанным далее:

\begin{itemize}
    \item Скорость рендеринга
    \item Потребление памяти
    \item Скорость компиляции
\end{itemize}

\subsection{Качественные параметры}

\textbf{Популярность} существующих решеиний - важный параметр сравнения поскольку чем более он популярен, тем проще получить поддержку, тем больше экосистема, тем больше гарантия отсутсвия багов.

Все фреймворки в работе устанавливаются с помощью системы менеджмента пакетов opam.
Однако, она не предоставляет статистику использования различных пакетов.
В связи с этим для оценки популярности будет использоваться статистика Advanced Search на сайте GitHub.
Этот инструмент ограничен в своих возможностях, поэтому будут сделаны следующие предположения:
\begin{itemize}
    \item Проект доступен через GitHub.
    \item Проект использует opam в качестве системы менеджмента пакетов.
    \item Проект явно указывает использование фреймворка в качестве зависимости.
\end{itemize}

Поскольку tyxml\% является лишь частью tyxml а не отдельным фреймворком, он включен в сравнение только как его часть.
Похожая проблема возникает с EML, поскольку он является частью dream.
В этом случае статистика ищется по ключевому слову eml.

\textbf{Покрытие} генерируется и измеряется с помощью bisect\_ppx.
Это стандартный инструмент в экосистеме OCaml.
Он создает отчет о покрытии кода тестами в формате HTML.
Примеры отчетов приведены в приложении % // TODO \ref{app:bisect-ppx}.

Фреймворки сравниваются с помощью тестовой страницы.
Чтобы продемострировать возможности каждого фреймворка, а также точность сгенерированного покрытия, она включает в себя условные конструкции, циклы и простые строки.
Полный псевдокод страницы приведен в приложении % // TODO \ref{app:test-page}.
Поскольку фреймворки отличаются по принципу обработки шаблонов, для каждого из них будет написана своя реализация этого функционала.

\textbf{Экосистема, дебаггинг и тестируемость} оцениваются вместе, поскольку эти характеристики похожи.
Для каждого фреймворка ищутся соответсвующие инструменты и сравниваются в степени поддержки.
Чем более популярен инструмент / считается стандартным решением - тем считается лучше.

\textbf{Документация} каждого шаблонизатора оценивается по следующим параметрам: полнота, наличие примеров, актуальность и наличие описания принципа работы фреймворка.

% // TODO: попытаться объяснить почему я сравниваю эти параметры

\subsection{Количественные параметры}

\textbf{Общий подход}

Для сравнения производительности шаблонизаторов создана страница, генерирующая некоторое количество похожих маленьких элементов.
Каждый фреймворк получает свою реализацию этой страницы.
Дабы избежать погрешностей связанных с операционной системой, все тесты помещены в один исполняемый файл и запуск программы осуществляется несколько раз.
Время измеряется с помощью функции time описанной в % // TODO добавить описание в приложение
После чего результаты агрегированы с помощью python и размещены на графике.
Выдвигается гипотеза что результирующий HTML генерируется алгоритмом с асимптотикой $\mathcal{O}(n)$, где n - количество сгенерированных элементов.
По точкам затем строится линейная аппроксимация с помощью метода наименьших квадратов.

Потребление памяти измеряется с помощью функции memory\_usage описанной в % // TODO добавить описание в приложение

% // TODO: упомянуть возникшую проблему с тем как я генерировал страницу?
% // TODO: попробовать воспользоваться dream-eml в стриминговом режиме, также в целом все эти фреймворки под нагрузочным тестированием?
