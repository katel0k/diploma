% Актуальность исследования обусловлена растущими требованиями к производительности веб-приложений.
% Несмотря на увеличение вычислительных мощностей, пользователи сталкиваются с проблемой медленной загрузки сайтов, что подтверждается статистикой роста размеров веб-страниц.

Обзор эволюции веб-рендеринга (1990–2020-е) Современная веб-разработка прошла три ключевых этапа, каждый из которых определял архитектурные подходы к рендерингу:
 Статическая эра (1990-е) Первые сайты (CERN, 1991) использовали ручную верстку HTML. Рендеринг выполнялся исключительно на клиенте, что ограничивало интерактивность («Статический веб: архитектура без состояний», Бернерс-Ли, 1998).
Динамическая революция (2000-е) Внедрение CGI (Common Gateway Interface) и серверных языков (PHP, ASP) позволило генерировать HTML на лету. Доминирующей стала модель SSR (J2EE Servlets, Rails), но рост сложности привёл к «кризису шаблонов» («Динамический веб: проблемы масштабирования», Fowler, 2004).
Эпоха SPA (2010-е) Появление AJAX и фреймворков (AngularJS, React) сместило рендеринг на клиент (CSR). Исследование Google (2016) показало, что 53\% SPA нарушали Core Web Vitals из-за TTI > 5s («Стоимость клиентского рендеринга», Addy Osmani, 2017).
Ренессанс SSR (2020-е) Гипертрофия JS-бандлов (средний размер 1.4MB в 2022, HTTP Archive) и требования SEO спровоцировали возврат к гибридным моделям (Next.js, Nuxt). Исследование Shopify подтвердило: переход на SSR снижает TTI на 62\% («Оптимизация электронной коммерции», 2021).
Ключевые драйверы SSR:
Рост мобильного трафика (58\% в 2023, StatCounter) с нестабильным соединением
Ужесточение SEO-алгоритмов (Google Core Web Vitals, 2021)
Запрос на энергоэффективность («Зелёный веб», W3C, 2022)

Современные требования к веб-приложениям формируют парадокс: при росте вычислительных мощностей на 40\% ежегодно \cite{moore2023web}, 53\% пользователей отмечают увеличение времени загрузки страниц \cite{akamai2022}.
Это противоречие обусловлено:
ростом сложности SPA\footnote{Single-page application} с медианным размером JS-бандла 1.8MB;
неэффективностью клиентского рендеринга (CLS\footnote{Cumulative Layout Shift} > 0.3 у 42\% сайтов;
ограничениями SEO-индексации динамического контента.

% Цель данной дипломной работы - исследование доступных способов создания серверных приложений используя методы функционального программирования, а также доработка некоторых из них.

% \textbf{Цель работы}: сравнительный анализ шаблонизаторов для фреймворка Dream на языке OCaml и оптимизация наиболее перспективного решения.

% Исходя из цели, в дипломной работе поставлены и решены следующие задачи:

% \begin{enumerate}
%     \item Обзор существующих решений;
%     \item Разработка подхода для оценки практической применимости решений
%     \item Качественное и количественное сравнение этих решений;
%     \item Выявление проблем в dream-eml
%     \item Оптимизация механизма рендеринга dream-eml
%     \item Исправление другие выявленных проблем
%     \item Валидация результатов через нагрузочное тестирование
% \end{enumerate}

SSR\footnote{Server-side rendering} становится ключевым решением, но существующие реализации на JS (Next.js, Nuxt) сохраняют фундаментальные недостатки:

Фреймворком dream пользуются большое количество проектов.

Как видно, этими решениями пользуются, ондако dream eml несмотря на то что он поставляется вместе с dream пользуются меньше всего.
Хотелось бы это исправить




В процессе работы исследуется также интеграция этих фреймворков с основным инструментом исследования покрытия кода тестами - bisect-ppx.
Его выбор обоснован популянростью, также рекомендацией научного руководителя


\textbf{Научная новизна} предложен механизм снижения аллокаций памяти в шаблонизаторах с сохранением чистоты функций.

\subsection{Проблема производительности веб-приложений}
Современные SPA\footnote{Single-page application}-приложения столкнулись с фундаментальным ограничением: необходимость выполнения значительного объема JavaScript-кода на стороне клиента перед отображением контента. % // TODO: докинуть библиографию
Многие сайты стали загружаться по несколько секунд, изначально показывая только белую страницу. % // TODO: докинуть библиографию
Особенно в мобильных устройствах, где загрузка страницы может занимать до 30 секунд. % // TODO: докинуть библиографию
Это также ухудшает показатели для поисковых двигателей - SEO\footnote{Search Engine Optimization}-индексация. % // TODO: докинуть библиографию
Общее время загрузки страниц - TTI\footnote{Time to Interactive} - становилось больше, чем раньше. % // TODO: докинуть библиографию

В противоположность, SSR\footnote{Server-side rendering} позволяет создавать веб страницы на стороне сервера, что устраняет необходимость выполнения JavaScript-кода на стороне клиента. % // TODO: докинуть библиографию
По информации издания CNews, первое решение на основе этой технологии было представлено в 2001 году. % https://www.cnews.ru/news/line/tehnologii_razrabotki_vebservisov

% \begin{itemize}
%     \item Мгновенную отдачу контента
%     \item Улучшение Core Web Vitals
%     \item Полную SEO-совместимость
%     \item Кеширование результатов
%     \item Сокрытие исходного кода
% \end{itemize}

Сама проблема была вызвана чрезмерным использованием веб-фреймворков, среди которых наиболее популярен React.js. % // TODO: докинуть библиографию
В его основе лежит компонентная модель на основе чистых функций, которая позволяет создавать пользовательские компоненты, которые могут быть использованы в разных местах приложения. % // TODO: докинуть библиографию
Его популярность также вызвана использованием JSX как декларативным языком разметки. % // TODO: докинуть библиографию
С учетом этих факторов логично рассмотреть возможность использования функциональных языков для разработки веб-серверов. 

В работе для рассмотрения был выбран OCaml из-за его позиционирования как промышленного языка.
Среди уникальных черт OCaml можно выделить его скорость в связи с нативной компиляцией в C, статическую типизацию, а также растущую популярность. % // TODO: докинуть библиографию

Наиболее популярное решение для разработки веб-серверов на OCaml - Dream. % // TODO: докинуть библиографию

